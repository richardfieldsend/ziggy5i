#
# Emacs 29 Configuration file using Org Mode. Check comments below for extra information
#

# The Preamble.
#+title: Emacs 29 Configuration File - Using Literate Programming and Org mode.
#+author: Richard Fieldsend
#+email: richardfieldsend@gmail.com
#+language: en
#+latex_class: article
#+latex_header: \usepackage[margin=2cm]{geometry}

#+begin_abstract
This file, config.org, is a standard Org mode file supporting Org mode
markup. It is special in that it supports the use of Babel tangling of
programming components. Upon starting Emacs the file is read, compiled
into a second file 'config.el' which contains just the code, and this
is then used as the configuration file for the program. The literate
functionality is derived from the work of Donald Knuth who felt that
programming had moved beyond being code with comments, to being best
achieved by writing descriptive text and embedding the code into the
literate explanation of how it works.

I think there is an argument for the fact that many higher languages
made literate programming less important because well written code in
those languages is straightforward enough to follow, but the literate
coding approach is still useful when you need to explain how your code
is intended to work, and it works so darn well with Org Mode and
Emacs, so it would be a shame to not use it!
#+end_abstract

# The preamble is used to set items such as the document title, author etc.

* Introduction.

The central premise of using the literate programming paradigm is to
write explanatory text describing your thought processes regarding how
you plan for your code to work, and to then embed the code itself
within the file in such a way as it will then be processed into useful
code when the file is processed. In the case of this file the original
file 'config.org' will be processed to generate the file config.el,
containing just the Emacs Lisp code responsible for setting up Emacs.

I'm rebuilding the config.org file, including more Org related stuff
(like a title, author and abstract) as I have also upgraded Emacs to
the development version Emacs 29.0.50 (April 2022). I'm going to try
and arrange the file into some sort of order too, while also placing
it under version control *before* I have version control configured
within Emacs. The order of things may change, but I'll try and make it
logical.

* Emacs Customisation Code

** Activating the Org Mode and Enabling Use Package Functionality.

The first source code component of the config.org files configures the
support for package installing, linking to the MELPA repository for
the code packages used by Emacs in the rest of the file. The 'Use
Package' functionality that this enables makes adding the
functionality a case of using 'use-package' and then the package file
name.

#+caption[Use Package]: Configure Org Mode source code for Emacs Lisp
#+begin_src emacs-lisp
    (eval-and-compile)
      (require 'package)
      (add-to-list 'package-archives
		   '("melpa" . "https://melpa.org/packages/"))
      (package-initialize)
      (package-refresh-contents)
      (unless (package-installed-p 'use-package)
	(package-install 'use-package))
      (require 'use-package)
      (setq use-package-always-ensure t)
#+end_src

*** TODO Investigate how best to label source code blocks.

** Look And Feel.

*** Simplifying Emacs Interface Configuration Using Built-in Functionality.

First things first. I know that I saw a blog post not so long ago that
argued that the Emacs community is not doing itself any favours by
suggesting to beginners that they turn off the menu bar and tool
bar. The argument, which I think was probably quite valid, was that it
was difficult for a new user to become familiar with a piece of
software if they had to rely on keyboard commands. However, I have
been using Emacs for a long time now, have most of the keyboard
shortcuts I need to know memorised, and so I don't need things like
the toolbar or menu. To this end, this next section of code switches
off some of the functionality which I don't need, freeing up screen
real estate, for the stuff I really want.

For clarification:
- Menu Bar Mode - removes the classic 'File Edit etc' menu bar
- Tool Bar Mode - removes the icons for things like 'save'
- Blink Cursor Mode - makes cursor a steady block rather than flashing
  one.
- Scroll Bar Mode - remove the scroll bar. I use other ways to move
  around.
- Display Time Mode - Put time in the information bar at bottom of
  window.
- Display Batter Mode - Information (largely the amount of charge)
  about the battery.

Having switched off the tool bar, menu bar and scroll bar, the
interface is much sparser, with just the editing window and the
information bar at the foot of the window. This information bar is
augmented with time and battery information.

The customisation continues from here, but this does create a fairly
blank canvas to work with. At this stage, however, the text is in a
pretty so-so font, the background is plain white, and it needs to be
made much prettier. Onwards and upwards.

#+caption[builtin aesthetics]: Built-in functions to manage the appearance of Emacs.
#+begin_src emacs-lisp
  (menu-bar-mode 0)			; Turn off menu bar
  (tool-bar-mode 0)			; Turn off the icons
  (blink-cursor-mode 0)			; Stop cursor blinking.
  (scroll-bar-mode 0)			; Where we're going, we don't need no scroll bar
  (display-time-mode 1)			; Add clock into mode line
  (display-battery-mode 1)		; Show battery mode on modeline
#+end_src

*** Not Making A Splash.

The standard Emacs startup includes a relatively simple startup screen
with a graphic and some links to things like the Emacs manual. I would
prefer to have no splash screen, but a simple bit of text.

#+caption[NoSplash]: Switch off the Emacs splash screen.
#+begin_src emacs-lisp
  (setq inhibit-startup-message t)	; Splash Screen Disabled.
#+end_src

I have configured this text in the past in such a way that each
computer that I run Emacs on uses a different bit of text. As I'm
starting this from scratch I will just add the quote, crafted for this
laptop (ziggyi5), but with information on how to create the text for
other machines so that if I need to add others in the future I'll
remember how to do it.

Initially, the only computer I am interested in providing this text
for is this one. The selection of the text is carried out on the basis
of the name of the system name. To determine the system name as far as
Emacs is concerned you can use the describe-variable function and then
ask to see the variable 'system-name'. To do this:

- M-x describe-variable
- Enter system-name

On this laptop the system name is ziggyi5

#+caption[startuptext]: Display defined text on the basis of the system name.
#+begin_src emacs-lisp
  ;; The laptop 'ziggyi5' is an 11th Gen i5 processor Dell
  (if (string=(system-name) "ziggyi5")
      (setq initial-scratch-message
	    "We demand rigidly defined areas of doubt and uncertainty!\n\tVroomfondel The Philosopher\n\n\tDouglas Adams, The Hitchhikers Guide To The Galaxy."))
#+end_src

Other computers can be added in with their own particular bit of text
by simply adding another check against the system name on that
machine.

*** Selecting A Nicer Font.

One of the most popular posts on Emacs Porn on Reddit appears to be
discussions an which fonts people like to use in Emacs. I don't really
mind the default one that I have now, but I do think that there are
nicer fonts, so I occassionally pick a different one for a period.

#+caption[nice font]:Selecting a nicer font for using Emacs day to
day.
#+begin_src emacs-lisp
  ;; Setting font to Hack.
  (add-to-list 'default-frame-alist '(font . "Hack-9"))
  (set-face-attribute 'default nil
		      :family "Hack")
#+end_src

** Core Functionality That Affects All Of Emacs.

This section is intended to provide behaviour that works everywhere
within Emacs. It will cover behaviour such as where backup files are
saved, the creation of abbreviation expansions and the like.

*** Creating File Backups At Save, But Keep Them Out Of The Way.

I would like to keep a small number of backups for files, but not have
them litter the folders where the files live. The default behaviour
for Emacs is to keep a previous version of the file with a tilde (~)
appended to the name. This works, but doesn't play nicely with proper
version control (the backups have to be excluded from the repository),
and doesn't even really provide a fallback as you only have the most
recent version.

The suggested configuration from the Emacs Wiki is to create a backup
folder for all the old versions to be placed in, and to then configure
the system to keep a restricted number of copies of the files.

#+caption[backupconfig1]: Configuring backing up of old copies to a single folder.
#+begin_src emacs-lisp
  ;; Code fragment from: https://www.emacswiki.org/emacs/BackupDirectory
  (setq backup-by-copying t      ; don't clobber symlinks
	backup-directory-alist
	'(("." . "~/.Backups/"))    ; Put all the backups in this folder
	delete-old-versions t	  ; Remove older files as required.
	kept-new-versions 6	  ; Keep 6 most recent versions
	kept-old-versions 6	  ; Keep 2 oldest versions
	version-control t		  ; use versioned backups
	vc-make-backup-files t	  ; Backup files, even when under Version Control
	auto-save-interval 60	  ; Auto save interval in seconds
	auto-save-timeout 60	  ; Auto save timeout
	auto-save-file-name-transforms '((".*" "~/.Backups/" t)))
#+end_src

*** Returning To The Same Place When Returning To A File.

There will be times when you want to edit the same file over and over,
and you don't want to have to search for where you were editing
before. Even if you know that you want to go straight to the end of
the file (M->) it is useful to have the cursor return to the original
location. This is provided by the Emacs 'Save Place'
functionality. This changed at some point around version 25, but I
only need to know about this newer behaviour as this is version
29.0.50 that I'm dealing with.

#+caption[Save Place]:Save cursor position and return there next time
#+begin_src emacs-lisp
  ;; Code for this is described on webpage: https://www.emacswiki.org/emacs/SavePlace
  (save-place-mode 1)			    ; Turn on 'return to previous location'
  (setq save-place-file "~/.Backups/.places") ; Location of the places file.
#+end_src

*** Maintain a Command History Between Restarts.

It may be controversial, but sometimes you may choose to restart Emacs
because you are doing one of the few things that it doesn't do. If you
go back to the system later you probably want to be able to use the
previous commands again, so in the same way that Bash's history
persists between restarts, this sections sets up the same behaviour in
Emacs.

#+caption[commandhistory]:Maintain a command history in Emacs.
#+begin_src emacs-lisp
  ;; This was originally flagged in Sacha Chua's guide to C3F here:
  ;; https://www.wisdomandwonder.com/wp-content/uploads/2014/03/C3F.html
  ;; See description below.
  (setq savehist-file "~/.Backups/savehist"
	history-length t
	history-delete-duplicates t
	savehist-save-minibuffer-history 1
	savehist-additional-variables
	'(kill-ring
	  search-ring
	  regexp-search-ring))
  (savehist-mode 1)
#+end_src

With this configuration in place, starting a new Emacs session gives
access to previous commands as used within the minibuffer. This can be
useful, either in looking back so you can re-run a command, or to find
a previous command, 'fix' it and run the new version.

*** Highlighting The Current Line.

The next function to enable is one that helps you to locate the line
that the cursor is on. The approach is simple. The line is
highlighted.

#+caption[linehighlight]:Highlight the line that the cursor is on.
#+begin_src emacs-lisp
  ;; Highlight the current line.
  (global-hl-line-mode 1)
#+end_src

*** Global Line Numbering.

Line numbering is useful as you can go directly to a line using M-g g
or M-g M-g.

#+caption[lineNumbering]:Display line numbers on the left edge of screen.
#+begin_src emacs-lisp
  ;; Activate line numbering
  (global-linum-mode t)
#+end_src

*** Transparency For Emacs.

One of the most popular look and feel changes that has lots of cool,
but not much real function is transparency. The function below will
lower the opacity of the window so that you can see the wallpaper
behind it. The 85/50 values can be tweaked as required.

#+caption[transparency]:Transparency for the Emacs window.
#+begin_src emacs-lisp
  (set-frame-parameter (selected-frame) 'alpha '(85 50))
  (add-to-list 'default-frame-alist '(alpha 85 50))
#+end_src

The first figure (currently 85) appears to be the opacity of the
window, so decreasing it will make the page more transparent.

*** White Space Trimming When Saving

When working on files for a long period it is possible to end up
adding blank lines at the end of the file. In most cases these are
harmless, but in some programming languages it can be
problematic. Because of this it is possible to trim the white space at
the end of the file when the file is saved.

#+caption[whitespaceTrimming]:Trim white space automatically when the file is saved.
#+begin_src emacs-lisp
  ;; Run 'delete-trailing-whitespace function when the file is saved
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

Extra lines are trimmed before the file is saved. This works as
expected. I made a 'todo' note in an earlier version of this file
regarding having a configuration that removed double spaces after a
full stop, as this is no longer deemed to be the way things should be
apparently, but given that my plan is to use Emacs to generate LaTeX
and this puts in the double spaces anyway, no problem, I can ignore
the issue.

*** Easier Responses to Yes Or No Questions.

There are a number of times when Emacs may need to ask for
confirmation before carrying out an action. For instance, closing or
killing a buffer which has been edited since it was last saved. The
standard requirement is for responses to be of the form yes or
no. This is way too many characters for a user to type, so the
following function converts the requirement to y or n.

#+caption[yorn]:Yes or No responses using single characters.
#+begin_src emacs-lisp
  ;; A one line function to request a single letter y or n and return
  ;; true if y or nil if n (compiled Lisp code built in to Emacs)
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

This is one of those little tweaks which is so useful that you don't
even realise you have it switched on until it isn't there and you miss
it!

*** Making The Default Emacs mode Text Mode.

Emacs has a number of special behaviours that are present only within
specific modes. These modes include things like 'fundamental', 'text',
'LaTeX' and 'Org'. In most cases the mode is triggered by the type of
file which has been loaded, but previous testing has indicated that
Text mode is the preferred base mode. To this end I have made this the
default mode by the setting below.

#+caption[textMode]:Make the default mode 'Text Mode'.
#+begin_src emacs-lisp
  ;; Set the default major mode to text.
  (setq-default major-mode 'text-mode)
#+end_src

*** Activate Line Wrapping in Popular Modes.

One of the things that is a very obvious difference between Emacs and
word processors is that vanilla emacs doesn't wrap lines of text by
default. In the world of programming that Emacs comes from, I guess
that this made some sense, or that it allowed for the sort of
flexibility that Emacs is famed for. However, while I have been
writing the text in this file, I have had to switch on word wrapping
when logging in. Obviously the best approach is to actually activate
it in all circumstances and then the user can switch it off it
appropriate.

#+caption[autofill]:Activate auto-fill to wrap longer lines sensibly.
#+begin_src emacs-lisp
  ;; Activate auto-fill as a minor mode when activating the following
  ;; major modes. If I find that I am using other modes that require
  ;; word wrapping then they can be added to this function at a later
  ;; date.
  (add-hook 'text-mode-hook 'turn-on-auto-fill) ; text mode
  (add-hook 'LaTeX-mode-hook 'turn-on-auto-fill) ; AuCTeX mode
  (add-hook 'latex-mode-hook 'turn-on-auto-fill) ; LaTeX mode
  (add-hook 'org-mode-hook 'turn-on-auto-fill)   ; Org Mode
  (add-hook 'emacs-lisp-mode-hook 'turn-on-auto-fill) ; Emacs Lisp mode
  (add-hook 'fundamental-mode-hook 'turn-on-auto-fill) ; Fundamental mode
  (add-hook 'prog-mode-hook 'turn-on-auto-fill)	     ; Prog mode
#+end_src

*** Providing an Updating Time Stamp in Files When Saved.

This functionality should not be used for files which are going to be
placed in version control. The reason is that every time the file is
saved the timestamp string updates, which means that the file needs
checking in to version control, for an entirely unimportant update.

This doesn't mean that the use of time stamps isn't useful, just
choose whether to put the file into version control, or have the file
time stamped.

Time stamping of files is simple to arrange. The time stamp is created
by adding the text:

- Time-stamp: " "

  or

- Time-stamp: < >

within the first 8 lines of the file. The space between the quotation
marks or the angle brackets are then replaced with the time stamp.

#+caption[timestamp]:Time stamp generation activated.
#+begin_src emacs-lisp
  ;; Trigger the creation of the time stamp when the file is saved using
  ;; the file save hook.
  (add-hook 'before-save-hook 'time-stamp) ; run time stamp function when saving the file
  (setq time-stamp-pattern nil)		 ; don't modify time stamp format.
#+end_src

Information on the time stamp can be found here:

https://www.gnu.org/software/emacs/manual/html_node/emacs/Time-Stamps.html

Points to remember when using time stamps.

- need to be in the first 8 lines of file

- need a space between the " " or < >

- Start the text Time-stamp: with a capital T otherwise the timestamp
  isn't inserted.

*** Abbreviation Expansions.

**** Dynamic Expansion - In Document Lookup For Expansions.

This function is useful as a way of speeding up typing of terms which
are difficult to type, but which are already present within a
document. For example, the following is a piece of scientific
equipment:

Weissenberg Rheogoniometer

This is a bit of a handful to type, see also sub-arachnoid
haemorrhage or even the code delimiters in this document. In each
case, if the document already has the text in it, then you can use M-/
to look for a suitable expansion. Type:

Wei

then hit M-/ to expand this to Weissenberg, then hit space and M-/
again and the Rheogoniometer will be appended. Once you are used to
this, it can really accelerate your typing. By all accounts, the
expansions are drawn up on the basis of how close to the existing
entry your term is, so if you are writing on a particular subject then
this can really come into its own.

**** Dynamic Abbreviation Expansion - Replacing Text On The Fly.

**** TODO Hippie Expand investigate (Clojure reference)

The above is a great tool for those bits of text that only appear in
the odd document. Emacs also has a function where text is replaced on
the fly. This can be used to expand pre-determined text into a
suitable string. Among the useful expansions are:

tia - thanks in anticipation

bw - Best wishes

hth - hope that helps

r - Richard

m - Morag

l - Lizzie

Another really useful expansion is to fix the sorts of typos that
occur regularly.

hte - the

The code below configures the location of the abbreviation file which
I will place in the same folder as this configuration file in order
that it can be placed under version control.

#+caption[abbreviations]:Configuration of abbreviation expansion
#+begin_src emacs-lisp
    ;; Switch on abbreviation expansion minor mode and define where it is stored.
  (setq-default abbrev-mode t)
  (setq abbrev-file-name "~/.emacs.d/abbrev_defs")
  (setq save-abbrevs 'silent)
#+end_src

The process of expanding an abbreviation is automatic, but as this is
the case it is important to choose the string to be expanded
carefully. It shouldn't be a string that you are going to want to use
anywhere else. If an abbreviation is expanded and this isn't what is
required then there is a fix. The full guide can be found here:

https://www.gnu.org/software/emacs/manual/html_node/emacs/Expanding-Abbrevs.html

To unexpand an expanded abbreviation use:

M-x unexpand-abbrev

**** Adding Abbreviations For Expansion.

With the cursor sitting at the end of the string to be expanded enter:

C-x a i g - Add global abbreviation for use in all modes

C-x a i l - Add local abbreviation for use in current mode.

*** Native Code Indentation In Org Mode Code Blocks.

So far, in this file, I have only been adding Emacs Lisp code blocks,
which makes sense as the code is configuring the way that Emacs
works. Lisp isn't particularly indent sensitive, caring much more
about parentheses.

This functionality manages the way that Org Mode manages the indenting
in the code blocks, enabling the native indentation for each language.

#+caption[orgIndentation]:Native Indenting Of Coding In Org Code Blocks.
#+begin_src emacs-lisp
  ;; Manage Org Mode Code Blocks by having tabs act natively within the code blocks.
  (setq org-src-tab-acts-natively t)
#+end_src

This entry may need to be tested with languages that care more about
indentation than Lisp, but having added the above, the text appears to
indent appropriately in Lisp mode.

*** Emacs Frame Title - Better Text.

The frame title for the Emacs window is, by default, pretty
generic. It lists the file being worked on, the name of the program
(GNU Emacs) and the machine name, but this can be modified.

#+caption[title]:Set the window title to something useful.
#+begin_src emacs-lisp
  ;; Set frame title
  (setq frame-title-format '("Emacs - Buffer: %b : File %f : Mode %m"))
#+end_src

This function modifies the frame title text to read:

Emacs - Buffer: active buffer : File file location : Mode mode

*** Bookmarking In Emacs.

One method of being able to navigate back to specific locations is to
use bookmarks.

#+caption[bookmarks]:Bookmarks in Emacs.
#+begin_src emacs-lisp
  ;; Configure the location for my Bookmarks file and create a trigger so that it gets
  ;; saved automatically when Emacs saves files.
  (set 'bookmark-default-file "~/.Backups/.bookmarks")
  (add-hook 'before-save-hook 'bookmark-save)
#+end_src

The commands for using bookmarks are:

C-x r m - Mark the current location as a bookmark.

C-x r b - Jump to a bookmark

C-x r l - List the available bookmarks.

The bookmarks list can be navigated and edited from the bookmarks
list. More information on managing the bookmarks list can be found
here:

https://www.emacswiki.org/emacs/BookMarks


** Package Based Functionality.

*** Introduction.

The code in this section uses various packages to enhance the
funcionality of Emacs. In general these packages are part of the Melpa
repositories and are installed using 'use-package'.

*** Packages Affecting All Emacs Modes

**** recentf - Re-open Files Used Recently.

#+caption[recentf]:Re-opening Files Recently Opened.
#+begin_src emacs-lisp
  ;; recentf - A Package To Re-Open files.
  (use-package recentf
    :config
    (setq recentf-save-file "~/.Backups/.recentf")
    recentf-max-saved-items 500
    recentf-max-menu-items 50
    (recentf-mode +1)
    (global-set-key (kbd "C-x C-r") 'recentf-open-files))
#+end_src

Having seemingly enabled this, I restarted Emacs and found that the
key combination opened 'find file, read only'. This is because the
abbreviation expansion had done its thing on the above command, making
in C-x C-Richard!

Now to test it. It works exactly as I had hoped, the correct key
strokes gives a list of the most recent documents, a quick way to
return to the same document, especially when you are working on the
same file over and over.

*** Packages Affecting Look And Feel

I have been happily working with the default theme while creating the
configuration file so far, but now it is time to introduce a nicer,
darker theme. There are many, many Emacs themes available, so it is
nice to change them up once in a while.

#+caption[colourtheme]:Using Emacs Colour Theme to change the colour scheme.
#+begin_src emacs-lisp
  ;; The use-package for the colour schemes is doom-themes because they were
  ;; originally intended for use with Doom Emacs. The Git repository is here:
  ;; https://github.com/doomemacs/themes
  ;; and screenshots showing how the themes look can be found here:
  ;; https://github.com/doomemacs/themes/tree/screenshots
  (use-package doom-themes
    :config
    ;; global settings (defaults)
    (setq doom-themes-enable-bold t	; if nil, bold is disabled
	doom-themes-enable-italic t)	; if nil, italic is disabled
    (load-theme 'doom-zenburn t)
    ;; Enable flashing line mode line on error
    (doom-themes-visual-bell-config)

    ;; Enable custom neotree theme (all-the-icons must be installed)
    (doom-themes-neotree-config)
    ;; or, for treemacs users
    (setq doom-themes-treemacs-theme "doom-colors") ; use the colourful treemacs theme
    (doom-themes-treemacs-config)

    ;; Corrects (and improves) org-mode's native fontification
    (doom-themes-org-config))
#+end_src

Initial testing with doom-material looked good, but the comments are
quite difficult to read. Testing a number of other themes, many of
them had the same issue. Looking a previous version of this
configuration file, I had settled on Zenburn, and this does have nice,
readable comment text, so I have returned to using that for the time
being.

*** Rainbow Delimiters - Coloured Brackets For Readability.

Whether the brackets are parentheses, curly or square, many
programming languages rely on brackets. Tracking brackets can be
difficult to do and errors are easily introduced by having unpaired
brackets in code.

Emacs makes it easier to track the pairing by colouring brackets which
constitute a pair in the same colour.

This function also includes 'electric' functionality which will
automatically add the closing bracket when the opening bracket is
inserted *and* puts the cursor in between the brackets ready to add
text.

#+caption[electricrainbow]:Rainbow delimiters and electric delimiter pairing.
#+begin_src emacs-lisp
  ;; Rainbow Delimiters Configured On Per Mode Basis.
  (use-package rainbow-delimiters
    :ensure t
    :init
    :config (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
    :config (add-hook 'LaTeX-mode-hook 'rainbow-delimiters-mode)
    :config (add-hook 'latex-mode-hook 'rainbow-delimiters-mode)
    :config (add-hook 'text-mode-hook 'rainbow-delimiters-mode)
    :config (add-hook 'org-mode-hook 'rainbow-delimiters-mode))
  ;; Electric behaviour such as adding closing brackets when opening bracket inserted
  (use-package electric
    :ensure t
    :init
    :config (add-hook 'prog-mode-hook 'electric-pair-mode)
    :config (add-hook 'LaTeX-mode-hook 'electric-pair-mode)
    :config (add-hook 'latex-mode-hook 'electric-pair-mode)
    :config (add-hook 'text-mode-hook 'electric-pair-mode)
    :config (add-hook 'org-mode-hook 'electric-pair-mode))
#+end_src

In the future I might choose a different colour theme as the brackets
in this theme don't look strikingly different, but I find that the
inserting of the closing bracket is the most useful part of the
process anyway.

*** Enhancing The Mode Line - Using The Doom Mode Line.

The standard mode line is informative, but not pretty. This
configuration ass an indicator for the file type (requiring
installation of the 'all-the-icons' package) and a Doom theme.

#+caption[modeline]:Improving the appearance of the Mode Line.
#+begin_src emacs-lisp
  ;; Install the 'all-the icons' and doom-modeline packages.
  (use-package all-the-icons)
  (use-package doom-modeline
    :hook (after-init . doom-modeline-mode)
    :config (setq doom-modeline-icon t))	; trigger icon display in the mode line.
  (use-package all-the-icons-dired)
  (add-hook 'dired-mode-hook 'all-the-icons-dired-mode)
#+end_src

Note that when the all-the-icons package in installed it is necessary
to follow this up by running the command 'all-the-icons-install-fonts'
as well. Until this is done the icons aren't available and you just
get odd boxes where the icons should be. The answer to this issue was
found on this Reddit post:

https://www.reddit.com/r/emacs/comments/s7828m/alltheicons_icons_not_showing_properly/

Also added the all-the-icons-dired functionality so that the icons
appear in the dired mode. This requires triggering the icons using the
dired hook in the above functions.

*** Provide Small Text Overview Using Minimap.

One popular function used in editors is to provide a sidebar which
shows the text of a proportion of the file in very small text. This
can help a person working on the file to understand where they are in
the body of the file. The minimap provides a visual indication on the
file, but it is in text which is far too small to be able to read. The
only feedback you get in realtime is that the line which the cursor is
on is marked in a colour to stand out. Using Zenburn as the theme for
Emacs gives an active line in Minimap with a blue background.

I'm never really sure whether I like this. I think it is quite a nice
idea if working on a larger screen (it is even possible that you could
have a screen which was large enough to make the text
readable). Switching it on and off seems a bit hit and miss, so I'll
give it a chance, and maybe comment out the code at a later date.

#+begin_src emacs-lisp
    (use-package minimap
      :config (setq minimap-major-modes '(tex-mode LaTeX-mode latex-mode prog-mode org-mode))
      :config (minimap-mode 1))
#+end_src

*** Add Fancy Bullets to Org Mode Documents.

Org Mode uses a simple markup language where headings of various
levels are marked by using one or more asterisk. As the number of
asterisks increase the whole thing begins to look a bit more
clunky. The fix for this is to replace the header asterisks with a
suitable fancy bullet.

#+caption[prettyorgbullets]:Pretty Bullets in Org Mode.
#+begin_src emacs-lisp
  ;; Pretty bullets when using Org Mode.
  (use-package org-bullets
    :config (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+end_src

*** Display Useful Git Information in Dired Buffers.

Dired mode, the Emacs file browser, is a sensible place to also
display some useful information regarding Git status. The following
function provides this behaviour.

#+caption[diredgit]:Git information displayed in Dired.
#+begin_src emacs-lisp
    ;; Enable Git display in Dired
    (use-package dired-git-info)
    (with-eval-after-load 'dired
      (define-key dired-mode-map ")" 'dired-git-info-mode))
#+end_src

To access the Git information within dired where Git information is
available then the above function includes a key map for toggling the
dired information on and off.

*** In-Emacs Version Control using Magit.

This is the first major package, providing a way of dealing with all
the Git functionality within Emacs.

#+caption[magit]:Magit and all its requirements.
#+begin_src emacs-lisp
  ;; Magit and its dependencies.
  (require 'diminish)
  (use-package magit
    :config (global-set-key (kbd "C-x g") 'magit-status))

  ;; Connect Magit documentation for use within Emacs.
  (with-eval-after-load 'info
    (info-initialize)
    (add-to-list 'Info-directory-list "~/.emacs.d/elpa/magit-20220412.2029/dir/"))
#+end_src

*** Helm - Filtering Commands Everywhere.

Helm is a filtering system which makes entering commands in Emacs
easier.

Rather than having to type the command that you want to run, you can
type the words that are part of that command, and Helm will filter
the available commands until you have the one you need at hand. I am
never quite sure what it does until I see Emacs running without it and
remember what I'm missing.

An example of it in action is the process I use for updating the
packages that I have installed in Emacs. It the absence of Helm I can
obtain a list of the packages that are available by typing:

M-x package-list-packages

Tab complete works once l has been entered.

However, with Helm in place I can type pack list and the command will
filter down to the one I want without any further action. This
filtering of available strings happens in many locations, simplifying
many Emacs processes.

#+caption[helm]:Helm - Providing string filtering everywhere.
#+begin_src emacs-lisp
  ;; Helm - Filtering everywhere. The Helm homepage can be found here:
  ;; https://emacs-helm.github.io/helm/
  (use-package helm
    :diminish helm-mode
    :init
    :config (require 'helm)
    :config (require 'helm-config)
    :config (helm-mode 1)
    :config (global-set-key (kbd "C-c h") 'helm-command-prefix)
    :config (global-unset-key (kbd "C-x c"))
    :config (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab run persistent action
    :config (define-key helm-map (kbd "C-z") 'helm-select-action)
    :config (global-set-key (kbd "M-x") #'helm-M-x)
    :config (global-set-key (kbd "C-x r b") #'helm-filtered-bookmarks)
    :config (global-set-key (kbd "C-x C-f") #'helm-find-files)
    ;; Change Helm buffer to be a small block at the base of the Emacs window, as described
    ;; in this page: http://tuhdo.github.io/helm-intro.html
    :config (setq helm-autoresize-max-height 0)
    :config (setq helm-autoresize-min-height 20)
    :config (helm-autoresize-mode 1))
#+end_src

The Helm package uses the Diminish package, but this is already
included by Magit.

Helm changes the way that some of Emacs works. For instance, the code
above modifies the command to open the list of bookmarks to show the
Helm based bookmark selection. At the moment this isn't massively
useful as I only have one file bookmarked (this one), but in the
future it can be much more useful. Other functions can also be tweaked
with Helm, so I have put the web pages that highlight how best to use
Helm in my Pocket documents for future reference.

*** Using Helm to control Spotify.

A little oddity which is fun to have in place, if only to show people
when they are accusing you of being a hacker. This function allows you
to manage Spotify without ever leaving the Emacs window. You can
search for tracks, play, pause and skip tracks, all while using the
One True Editor.

#+caption[helmspotify]:Using Helm to manage Spotify
#+begin_src emacs-lisp
  ;; Control Spotify from the comfort of your text editor.
  (use-package helm-spotify-plus
    :config (global-set-key (kbd "C-c s s") 'helm-spotify-plus)
    :config (global-set-key (kbd "C-c s f") 'helm-spotify-plus-next)
    :config (global-set-key (kbd "C-c s b") 'helm-spotify-plus-previous)
    :config (global-set-key (kbd "C-c s p") 'helm-spotify-plus-play)
    :config (global-set-key (kbd "C-c s g") 'helm-spotify-plus-pause))
#+end_src

To find music to play, you can search for the artist (prefix a:),
track (prefix t:) or market (prefix m:). For example:

- chumbawamba - free text search
- a:chumbawamba - artist search
- t:timebomb - track search
- a:bragg t:levi

Move through the results list and hit return to select a track to
play.

*** Achievements - Track Your Emacs Skillz.

There are multiple XKCD cartoons about Emacs (and Vi), about its
learning curve and how there is a function to do just about
anything. One of the downsides of this behaviour is that there is
always something to learn about how to get more out of your
editor. Achievements is a way of recording your progress and of
providing challenges to spur you on your way.

#+caption[achievements]:Measure your achievements while using Emacs.
#+begin_src emacs-lisp
  ;; Use achievements package to measure progress
  (use-package achievements
    :config (require 'achievements))
#+end_src

Once installed, a list of achievements can be viewed by entering the
command:

- achievements-list-achievements

However, while it does show which achievements have been reached, it
doesn't show what needs to be done for existing entries which are not
always obvious.

*** Which Key - Help To Master Emacs By Highlighting Keystrokes.

#+caption[whichkey]:Which Key - Master Emacs By Learning The Key Strokes
#+begin_src emacs-lisp
  ;; Which Key
  (use-package which-key
    :ensure t)
#+end_src

Emacs works best when you get to know all the key mapping, and
which-key helps you learn what the keys are.

*** Nov.el - Read ePub documents within Emacs.

Another package recommended by the author of Mastering Emacs as a way
to read his book within Emacs itself.

#+caption[epubreader]:ePub Reading Within Emacs.
#+begin_src emacs-lisp
      ;; Read ePub in Emacs.
      (use-package nov
	:ensure t
	:mode ("\\.epub\\'" . nov-mode)
	)
#+end_src

When this was originally configured it didn't work. Checking the
messages, it appeared that the problem was related to Emacs not being
compiled with the libxml2 support. To fix the problem:

- Install the libxml2 development library using sudo apt install
  libxml2-dev

- Rerun ./autogen.sh and then ./configure so that Emacs knows that
  libxml2-dev is installed.

- Run make -j 8 -o 3 && sudo make install

Now opening epub files works as expected.

*** Write Room - Distraction Free Writing Environment.

I'm interested, in general, in the idea of low distraction editing and
writing interfaces. There are a few ways that this can be achieved in
Emacs (Olivetti mode is also configured elsewhere in this
configuration).

#+caption[writeroom]:Write Room - Distraction Free Editing.
#+begin_src emacs-lisp
  ;; Write Room Mode - Keep It Simple.
  (use-package writeroom-mode)
#+end_src

When activated, Writeroom takes over the whole monitor, even when
using the i3 window manager, leaving you with just the Emacs screen,
with the modeline switched off. As I have turned off a lot of the
decoration on Emacs anyway (tool bar, menu bar and scroll bar), the
difference isn't as obvious as it would be if all of those things were
present, but it is a very sparse interface, with huge margins on each
side, even when the minimap is active. I like it on the big screen,
but I'm less convinced of it on a laptop screen. We'll see.

Looking at the helm menu and entering 'writeroom' I see that there is
a 'global-writeroom-mode', which appears to implement writeroom
everywhere, and there is a keyboard shortcut for toggling the
modeline, which, in Writeroom mode appears at the top of the
screen. The toggle is S-shift-? (S is the super key, otherwise known
as the Windows key).

Thus far, the presence of the modeline includes the line number and
position (as a percentage for the active line, but I think the next
change will add a word count).
