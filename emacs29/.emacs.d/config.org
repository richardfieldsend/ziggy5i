#
# Emacs 29 Configuration file using Org Mode. Check comments below for extra information
#

# The Preamble.
#+title: Emacs 29 Configuration File - Using Literate Programming and Org mode.
#+author: Richard Fieldsend
#+email: richardfieldsend@gmail.com
#+language: en
#+latex_class: article
#+latex_header: \usepackage[margin=2cm]{geometry}

#+begin_abstract
This file, config.org, is a standard Org mode file supporting Org mode
markup. It is special in that it supports the use of Babel tangling of
programming components. Upon starting Emacs the file is read, compiled
into a second file 'config.el' which contains just the code, and this
is then used as the configuration file for the program. The literate
functionality is derived from the work of Donald Knuth who felt that
programming had moved beyond being code with comments, to being best
achieved by writing descriptive text and embedding the code into the
literate explanation of how it works.

I think there is an argument for the fact that many higher languages
made literate programming less important because well written code in
those languages is straightforward enough to follow, but the literate
coding approach is still useful when you need to explain how your code
is intended to work, and it works so darn well with Org Mode and
Emacs, so it would be a shame to not use it!
#+end_abstract

# The preamble is used to set items such as the document title, author etc.

* Introduction.

The central premise of using the literate programming paradigm is to
write explanatory text describing your thought processes regarding how
you plan for your code to work, and to then embed the code itself
within the file in such a way as it will then be processed into useful
code when the file is processed. In the case of this file the original
file 'config.org' will be processed to generate the file config.el,
containing just the Emacs Lisp code responsible for setting up Emacs.

I'm rebuilding the config.org file, including more Org related stuff
(like a title, author and abstract) as I have also upgraded Emacs to
the development version Emacs 29.0.50 (April 2022). I'm going to try
and arrange the file into some sort of order too, while also placing
it under version control *before* I have version control configured
within Emacs. The order of things may change, but I'll try and make it
logical.

* Emacs Customisation Code

** Activating the Org Mode and Enabling Use Package Functionality.

The first source code component of the config.org files configures the
support for package installing, linking to the MELPA repository for
the code packages used by Emacs in the rest of the file. The 'Use
Package' functionality that this enables makes adding the
functionality a case of using 'use-package' and then the package file
name.

#+caption[Use Package]: Configure Org Mode source code for Emacs Lisp
#+begin_src emacs-lisp
    (eval-and-compile)
      (require 'package)
      (add-to-list 'package-archives
		   '("melpa" . "https://melpa.org/packages/"))
      (package-initialize)
      (package-refresh-contents)
      (unless (package-installed-p 'use-package)
	(package-install 'use-package))
      (require 'use-package)
      (setq use-package-always-ensure t)
#+end_src

*** TODO Investigate how best to label source code blocks.

** Look And Feel.

*** Simplifying Emacs Interface Configuration Using Built-in Functionality.

First things first. I know that I saw a blog post not so long ago that
argued that the Emacs community is not doing itself any favours by
suggesting to beginners that they turn off the menu bar and tool
bar. The argument, which I think was probably quite valid, was that it
was difficult for a new user to become familiar with a piece of
software if they had to rely on keyboard commands. However, I have
been using Emacs for a long time now, have most of the keyboard
shortcuts I need to know memorised, and so I don't need things like
the toolbar or menu. To this end, this next section of code switches
off some of the functionality which I don't need, freeing up screen
real estate, for the stuff I really want.

For clarification:
- Menu Bar Mode - removes the classic 'File Edit etc' menu bar
- Tool Bar Mode - removes the icons for things like 'save'
- Blink Cursor Mode - makes cursor a steady block rather than flashing
  one.
- Scroll Bar Mode - remove the scroll bar. I use other ways to move
  around.
- Display Time Mode - Put time in the information bar at bottom of
  window.
- Display Batter Mode - Information (largely the amount of charge)
  about the battery.

Having switched off the tool bar, menu bar and scroll bar, the
interface is much sparser, with just the editing window and the
information bar at the foot of the window. This information bar is
augmented with time and battery information.

The customisation continues from here, but this does create a fairly
blank canvas to work with. At this stage, however, the text is in a
pretty so-so font, the background is plain white, and it needs to be
made much prettier. Onwards and upwards.

#+caption[builtin aesthetics]: Built-in functions to manage the appearance of Emacs.
#+begin_src emacs-lisp
  (menu-bar-mode 0)			; Turn off menu bar
  (tool-bar-mode 0)			; Turn off the icons
  (blink-cursor-mode 0)			; Stop cursor blinking.
  (scroll-bar-mode 0)			; Where we're going, we don't need no scroll bar
  (display-time-mode 1)			; Add clock into mode line
  (display-battery-mode 1)		; Show battery mode on modeline
#+end_src

*** Not Making A Splash.

The standard Emacs startup includes a relatively simple startup screen
with a graphic and some links to things like the Emacs manual. I would
prefer to have no splash screen, but a simple bit of text.

#+caption[NoSplash]: Switch off the Emacs splash screen.
#+begin_src emacs-lisp
  (setq inhibit-startup-message t)	; Splash Screen Disabled.
#+end_src

I have configured this text in the past in such a way that each
computer that I run Emacs on uses a different bit of text. As I'm
starting this from scratch I will just add the quote, crafted for this
laptop (ziggyi5), but with information on how to create the text for
other machines so that if I need to add others in the future I'll
remember how to do it.

Initially, the only computer I am interested in providing this text
for is this one. The selection of the text is carried out on the basis
of the name of the system name. To determine the system name as far as
Emacs is concerned you can use the describe-variable function and then
ask to see the variable 'system-name'. To do this:

- M-x describe-variable
- Enter system-name

On this laptop the system name is ziggyi5

#+caption[startuptext]: Display defined text on the basis of the system name.
#+begin_src emacs-lisp
  ;; The laptop 'ziggyi5' is an 11th Gen i5 processor Dell
  (if (string=(system-name) "ziggyi5")
      (setq initial-scratch-message
	    "We demand rigidly defined areas of doubt and uncertainty!\n\tVroomfondel The Philosopher\n\n\tDouglas Adams, The Hitchhikers Guide To The Galaxy."))
#+end_src

Other computers can be added in with their own particular bit of text
by simply adding another check against the system name on that
machine.

*** Selecting A Nicer Font.

One of the most popular posts on Emacs Porn on Reddit appears to be
discussions an which fonts people like to use in Emacs. I don't really
mind the default one that I have now, but I do think that there are
nicer fonts, so I occassionally pick a different one for a period.

#+caption[nice font]:Selecting a nicer font for using Emacs day to
day.
#+begin_src emacs-lisp
  ;; Setting font to Hack.
  (add-to-list 'default-frame-alist '(font . "Hack-9"))
  (set-face-attribute 'default nil
		      :family "Hack")
#+end_src

** Core Functionality That Affects All Of Emacs.

This section is intended to provide behaviour that works everywhere
within Emacs. It will cover behaviour such as where backup files are
saved, the creation of abbreviation expansions and the like.

*** Creating File Backups At Save, But Keep Them Out Of The Way.

I would like to keep a small number of backups for files, but not have
them litter the folders where the files live. The default behaviour
for Emacs is to keep a previous version of the file with a tilde (~)
appended to the name. This works, but doesn't play nicely with proper
version control (the backups have to be excluded from the repository),
and doesn't even really provide a fallback as you only have the most
recent version.

The suggested configuration from the Emacs Wiki is to create a backup
folder for all the old versions to be placed in, and to then configure
the system to keep a restricted number of copies of the files.

#+caption[backupconfig1]: Configuring backing up of old copies to a single folder.
#+begin_src emacs-lisp
  ;; Code fragment from: https://www.emacswiki.org/emacs/BackupDirectory
  (setq backup-by-copying t      ; don't clobber symlinks
	backup-directory-alist
	'(("." . "~/.Backups/"))    ; Put all the backups in this folder
	delete-old-versions t	  ; Remove older files as required.
	kept-new-versions 6	  ; Keep 6 most recent versions
	kept-old-versions 6	  ; Keep 2 oldest versions
	version-control t		  ; use versioned backups
	vc-make-backup-files t	  ; Backup files, even when under Version Control
	auto-save-interval 60	  ; Auto save interval in seconds
	auto-save-timeout 60	  ; Auto save timeout
	auto-save-file-name-transforms '((".*" "~/.Backups/" t)))
#+end_src

*** Returning To The Same Place When Returning To A File.

There will be times when you want to edit the same file over and over,
and you don't want to have to search for where you were editing
before. Even if you know that you want to go straight to the end of
the file (M->) it is useful to have the cursor return to the original
location. This is provided by the Emacs 'Save Place'
functionality. This changed at some point around version 25, but I
only need to know about this newer behaviour as this is version
29.0.50 that I'm dealing with.

#+caption[Save Place]:Save cursor position and return there next time
#+begin_src emacs-lisp
  ;; Code for this is described on webpage: https://www.emacswiki.org/emacs/SavePlace
  (save-place-mode 1)			    ; Turn on 'return to previous location'
  (setq save-place-file "~/.Backups/.places") ; Location of the places file.
#+end_src

*** Maintain a Command History Between Restarts.

It may be controversial, but sometimes you may choose to restart Emacs
because you are doing one of the few things that it doesn't do. If you
go back to the system later you probably want to be able to use the
previous commands again, so in the same way that Bash's history
persists between restarts, this sections sets up the same behaviour in
Emacs.

#+caption[commandhistory]:Maintain a command history in Emacs.
#+begin_src emacs-lisp
  ;; This was originally flagged in Sacha Chua's guide to C3F here:
  ;; https://www.wisdomandwonder.com/wp-content/uploads/2014/03/C3F.html
  ;; See description below.
  (setq savehist-file "~/.Backups/savehist"
	history-length t
	history-delete-duplicates t
	savehist-save-minibuffer-history 1
	savehist-additional-variables
	'(kill-ring
	  search-ring
	  regexp-search-ring))
  (savehist-mode 1)
#+end_src

With this configuration in place, starting a new Emacs session gives
access to previous commands as used within the minibuffer. This can be
useful, either in looking back so you can re-run a command, or to find
a previous command, 'fix' it and run the new version.

*** Highlighting The Current Line.

The next function to enable is one that helps you to locate the line
that the cursor is on. The approach is simple. The line is
highlighted.

#+caption[linehighlight]:Highlight the line that the cursor is on.
#+begin_src emacs-lisp
  ;; Highlight the current line.
  (global-hl-line-mode 1)
#+end_src

*** Global Line Numbering.

Line numbering is useful as you can go directly to a line using M-g g
or M-g M-g.

#+caption[lineNumbering]:Display line numbers on the left edge of screen.
#+begin_src emacs-lisp
  ;; Activate line numbering
  (global-linum-mode t)
#+end_src

*** Transparency For Emacs.

One of the most popular look and feel changes that has lots of cool,
but not much real function is transparency. The function below will
lower the opacity of the window so that you can see the wallpaper
behind it. The 85/50 values can be tweaked as required.

#+caption[transparency]:Transparency for the Emacs window.
#+begin_src emacs-lisp
  (set-frame-parameter (selected-frame) 'alpha '(85 50))
  (add-to-list 'default-frame-alist '(alpha 85 50))
#+end_src

The first figure (currently 85) appears to be the opacity of the
window, so decreasing it will make the page more transparent.

*** White Space Trimming When Saving

When working on files for a long period it is possible to end up
adding blank lines at the end of the file. In most cases these are
harmless, but in some programming languages it can be
problematic. Because of this it is possible to trim the white space at
the end of the file when the file is saved.

#+caption[whitespaceTrimming]:Trim white space automatically when the file is saved.
#+begin_src emacs-lisp
  ;; Run 'delete-trailing-whitespace function when the file is saved
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

Extra lines are trimmed before the file is saved. This works as
expected. I made a 'todo' note in an earlier version of this file
regarding having a configuration that removed double spaces after a
full stop, as this is no longer deemed to be the way things should be
apparently, but given that my plan is to use Emacs to generate LaTeX
and this puts in the double spaces anyway, no problem, I can ignore
the issue.

*** Easier Responses to Yes Or No Questions.

There are a number of times when Emacs may need to ask for
confirmation before carrying out an action. For instance, closing or
killing a buffer which has been edited since it was last saved. The
standard requirement is for responses to be of the form yes or
no. This is way too many characters for a user to type, so the
following function converts the requirement to y or n.

#+caption[yorn]:Yes or No responses using single characters.
#+begin_src emacs-lisp
  ;; A one line function to request a single letter y or n and return
  ;; true if y or nil if n (compiled Lisp code built in to Emacs)
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

This is one of those little tweaks which is so useful that you don't
even realise you have it switched on until it isn't there and you miss
it!

*** Making The Default Emacs mode Text Mode.

Emacs has a number of special behaviours that are present only within
specific modes. These modes include things like 'fundamental', 'text',
'LaTeX' and 'Org'. In most cases the mode is triggered by the type of
file which has been loaded, but previous testing has indicated that
Text mode is the preferred base mode. To this end I have made this the
default mode by the setting below.

#+caption[textMode]:Make the default mode 'Text Mode'.
#+begin_src emacs-lisp
  ;; Set the default major mode to text.
  (setq-default major-mode 'text-mode)
#+end_src

*** Activate Line Wrapping in Popular Modes.

One of the things that is a very obvious difference between Emacs and
word processors is that vanilla emacs doesn't wrap lines of text by
default. In the world of programming that Emacs comes from, I guess
that this made some sense, or that it allowed for the sort of
flexibility that Emacs is famed for. However, while I have been
writing the text in this file, I have had to switch on word wrapping
when logging in. Obviously the best approach is to actually activate
it in all circumstances and then the user can switch it off it
appropriate.

#+caption[autofill]:Activate auto-fill to wrap longer lines sensibly.
#+begin_src emacs-lisp
  ;; Activate auto-fill as a minor mode when activating the following
  ;; major modes. If I find that I am using other modes that require
  ;; word wrapping then they can be added to this function at a later
  ;; date.
  (add-hook 'text-mode-hook 'turn-on-auto-fill) ; text mode
  (add-hook 'LaTeX-mode-hook 'turn-on-auto-fill) ; AuCTeX mode
  (add-hook 'latex-mode-hook 'turn-on-auto-fill) ; LaTeX mode
  (add-hook 'org-mode-hook 'turn-on-auto-fill)   ; Org Mode
  (add-hook 'emacs-lisp-mode-hook 'turn-on-auto-fill) ; Emacs Lisp mode
  (add-hook 'fundamental-mode-hook 'turn-on-auto-fill) ; Fundamental mode
  (add-hook 'prog-mode-hook 'turn-on-auto-fill)	     ; Prog mode
#+end_src

*** Providing an Updating Time Stamp in Files When Saved.

This functionality should not be used for files which are going to be
placed in version control. The reason is that every time the file is
saved the timestamp string updates, which means that the file needs
checking in to version control, for an entirely unimportant update.

This doesn't mean that the use of time stamps isn't useful, just
choose whether to put the file into version control, or have the file
time stamped.

Time stamping of files is simple to arrange. The time stamp is created
by adding the text:

- Time-stamp: " "

  or

- Time-stamp: < >

within the first 8 lines of the file. The space between the quotation
marks or the angle brackets are then replaced with the time stamp.

#+caption[timestamp]:Time stamp generation activated.
#+begin_src emacs-lisp
  ;; Trigger the creation of the time stamp when the file is saved using
  ;; the file save hook.
  (add-hook 'before-save-hook 'time-stamp) ; run time stamp function when saving the file
  (setq time-stamp-pattern nil)		 ; don't modify time stamp format.
#+end_src

Information on the time stamp can be found here:

https://www.gnu.org/software/emacs/manual/html_node/emacs/Time-Stamps.html

Points to remember when using time stamps.

- need to be in the first 8 lines of file

- need a space between the " " or < >

- Start the text Time-stamp: with a capital T otherwise the timestamp
  isn't inserted.

*** Abbreviation Expansions.

**** Dynamic Expansion - In Document Lookup For Expansions.

This function is useful as a way of speeding up typing of terms which
are difficult to type, but which are already present within a
document. For example, the following is a piece of scientific
equipment:

Weissenberg Rheogoniometer

This is a bit of a handful to type, see also sub-arachnoid
haemorrhage or even the code delimiters in this document. In each
case, if the document already has the text in it, then you can use M-/
to look for a suitable expansion. Type:

Wei

then hit M-/ to expand this to Weissenberg, then hit space and M-/
again and the Rheogoniometer will be appended. Once you are used to
this, it can really accelerate your typing. By all accounts, the
expansions are drawn up on the basis of how close to the existing
entry your term is, so if you are writing on a particular subject then
this can really come into its own.

**** Dynamic Abbreviation Expansion - Replacing Text On The Fly.

**** TODO Hippie Expand investigate (Clojure reference)

The above is a great tool for those bits of text that only appear in
the odd document. Emacs also has a function where text is replaced on
the fly. This can be used to expand pre-determined text into a
suitable string. Among the useful expansions are:

tia - thanks in anticipation

bw - Best wishes

hth - hope that helps

r - Richard

m - Morag

l - Lizzie

Another really useful expansion is to fix the sorts of typos that
occur regularly.

hte - the

The code below configures the location of the abbreviation file which
I will place in the same folder as this configuration file in order
that it can be placed under version control.

#+caption[abbreviations]:Configuration of abbreviation expansion
#+begin_src emacs-lisp
    ;; Switch on abbreviation expansion minor mode and define where it is stored.
  (setq-default abbrev-mode t)
  (setq abbrev-file-name "~/.emacs.d/abbrev_defs")
  (setq save-abbrevs 'silent)
#+end_src

The process of expanding an abbreviation is automatic, but as this is
the case it is important to choose the string to be expanded
carefully. It shouldn't be a string that you are going to want to use
anywhere else. If an abbreviation is expanded and this isn't what is
required then there is a fix. The full guide can be found here:

https://www.gnu.org/software/emacs/manual/html_node/emacs/Expanding-Abbrevs.html

To unexpand an expanded abbreviation use:

M-x unexpand-abbrev

**** Adding Abbreviations For Expansion.

With the cursor sitting at the end of the string to be expanded enter:

C-x a i g - Add global abbreviation for use in all modes

C-x a i l - Add local abbreviation for use in current mode.

*** Native Code Indentation In Org Mode Code Blocks.

So far, in this file, I have only been adding Emacs Lisp code blocks,
which makes sense as the code is configuring the way that Emacs
works. Lisp isn't particularly indent sensitive, caring much more
about parentheses.

This functionality manages the way that Org Mode manages the indenting
in the code blocks, enabling the native indentation for each language.

#+caption[orgIndentation]:Native Indenting Of Coding In Org Code Blocks.
#+begin_src emacs-lisp
  ;; Manage Org Mode Code Blocks by having tabs act natively within the code blocks.
  (setq org-src-tab-acts-natively t)
#+end_src

This entry may need to be tested with languages that care more about
indentation than Lisp, but having added the above, the text appears to
indent appropriately in Lisp mode.

*** Emacs Frame Title - Better Text.

The frame title for the Emacs window is, by default, pretty
generic. It lists the file being worked on, the name of the program
(GNU Emacs) and the machine name, but this can be modified.

#+caption[title]:Set the window title to something useful.
#+begin_src emacs-lisp
  ;; Set frame title
  (setq frame-title-format '("Emacs - Buffer: %b : File %f : Mode %m"))
#+end_src

This function modifies the frame title text to read:

Emacs - Buffer: active buffer : File file location : Mode mode
